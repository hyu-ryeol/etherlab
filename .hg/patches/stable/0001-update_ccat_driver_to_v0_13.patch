# HG changeset patch
# User Patrick Bruenn <p.bruenn@beckhoff.com>
# Date 1444731856 -7200
#      Tue Oct 13 12:24:16 2015 +0200
update ccat driver to v0.13
- add driver for the SRAM function block
- add driver for the GPIO function block
- add support for multiple CCATs
- prepare support for devices without pci
(grafted from 0613017547feee7a2189fe71724ca5bcd1fcb61f)

diff --git a/devices/ccat/Kbuild.in b/devices/ccat/Kbuild.in
--- a/devices/ccat/Kbuild.in
+++ b/devices/ccat/Kbuild.in
@@ -35,8 +35,10 @@ TOPDIR := $(src)/../..
 
 ifeq (@ENABLE_CCAT@,1)
 	EC_CCAT_OBJ := \
+		gpio.o \
 		module.o \
 		netdev.o \
+		sram.o \
 		update.o
 	obj-m += ec_ccat.o
 	ec_ccat-objs := $(EC_CCAT_OBJ)
diff --git a/devices/ccat/Makefile.am b/devices/ccat/Makefile.am
--- a/devices/ccat/Makefile.am
+++ b/devices/ccat/Makefile.am
@@ -29,8 +29,10 @@
 
 EXTRA_DIST = \
 	Kbuild.in \
+	gpio.h \
 	module.h \
 	netdev.h \
+	sram.h \
 	update.h
 
 BUILT_SOURCES = \
diff --git a/devices/ccat/gpio.c b/devices/ccat/gpio.c
new file mode 100644
--- /dev/null
+++ b/devices/ccat/gpio.c
@@ -0,0 +1,164 @@
+/**
+    Network Driver for Beckhoff CCAT communication controller
+    Copyright (C) 2014  Beckhoff Automation GmbH
+    Author: Patrick Bruenn <p.bruenn@beckhoff.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/version.h>
+#include "module.h"
+
+/**
+ * struct ccat_gpio - CCAT GPIO function
+ * @ioaddr: PCI base address of the CCAT Update function
+ * @info: holds a copy of the CCAT Update function information block (read from PCI config space)
+ */
+struct ccat_gpio {
+	struct gpio_chip chip;
+	void __iomem *ioaddr;
+	struct mutex lock;
+};
+
+/** TODO implement in LED driver
+	#define TC_RED 0x01
+	#define TC_GREEN 0x02
+	#define TC_BLUE 0x04
+	#define FB1_RED 0x08
+	#define FB1_GREEN 0x10
+	#define FB1_BLUE 0x20
+	#define FB2_RED 0x40
+	#define FB2_GREEN 0x80
+	#define FB2_BLUE 0x100
+ */
+
+static int set_bit_in_register(struct mutex *lock, void __iomem * ioaddr,
+			       unsigned nr, int val)
+{
+	volatile unsigned long old;
+
+	mutex_lock(lock);
+	old = ioread32(ioaddr);
+	val ? set_bit(nr, &old) : clear_bit(nr, &old);
+	if (val)
+		set_bit(nr, &old);
+	else
+		clear_bit(nr, &old);
+	iowrite32(old, ioaddr);
+	mutex_unlock(lock);
+	return 0;
+}
+
+static int ccat_gpio_get_direction(struct gpio_chip *chip, unsigned nr)
+{
+	struct ccat_gpio *gdev = container_of(chip, struct ccat_gpio, chip);
+	const size_t byte_offset = 4 * (nr / 32) + 0x8;
+	const u32 mask = 1 << (nr % 32);
+
+	return !(mask & ioread32(gdev->ioaddr + byte_offset));
+}
+
+static int ccat_gpio_direction_input(struct gpio_chip *chip, unsigned nr)
+{
+	struct ccat_gpio *gdev = container_of(chip, struct ccat_gpio, chip);
+
+	return set_bit_in_register(&gdev->lock, gdev->ioaddr + 0x8, nr, 0);
+}
+
+static int ccat_gpio_direction_output(struct gpio_chip *chip, unsigned nr,
+				      int val)
+{
+	struct ccat_gpio *gdev = container_of(chip, struct ccat_gpio, chip);
+
+	return set_bit_in_register(&gdev->lock, gdev->ioaddr + 0x8, nr, 1);
+}
+
+static int ccat_gpio_get(struct gpio_chip *chip, unsigned nr)
+{
+	struct ccat_gpio *gdev = container_of(chip, struct ccat_gpio, chip);
+	const size_t byte_off = 4 * (nr / 32);
+	const int mask = 1 << (nr % 32);
+	int dir_off;
+	int value;
+
+	/** omit direction changes before value was read */
+	mutex_lock(&gdev->lock);
+	dir_off = 0x10 * ccat_gpio_get_direction(chip, nr);
+	value = !(mask & ioread32(gdev->ioaddr + byte_off + dir_off));
+	mutex_unlock(&gdev->lock);
+	return value;
+}
+
+static void ccat_gpio_set(struct gpio_chip *chip, unsigned nr, int val)
+{
+	struct ccat_gpio *gdev = container_of(chip, struct ccat_gpio, chip);
+
+	set_bit_in_register(&gdev->lock, gdev->ioaddr, nr, val);
+}
+
+static const struct gpio_chip ccat_gpio_chip = {
+	.label = KBUILD_MODNAME,
+	.owner = THIS_MODULE,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+	.get_direction = ccat_gpio_get_direction,
+#endif
+	.direction_input = ccat_gpio_direction_input,
+	.get = ccat_gpio_get,
+	.direction_output = ccat_gpio_direction_output,
+	.set = ccat_gpio_set,
+	.dbg_show = NULL,
+	.base = -1,
+	.can_sleep = false
+};
+
+static int ccat_gpio_probe(struct ccat_function *func)
+{
+	struct ccat_gpio *const gpio = kzalloc(sizeof(*gpio), GFP_KERNEL);
+	int ret;
+
+	if (!gpio)
+		return -ENOMEM;
+
+	gpio->ioaddr = func->ccat->bar_0 + func->info.addr;
+	memcpy(&gpio->chip, &ccat_gpio_chip, sizeof(gpio->chip));
+	gpio->chip.ngpio = func->info.num_gpios;
+	mutex_init(&gpio->lock);
+
+	ret = gpiochip_add(&gpio->chip);
+	if (ret) {
+		kfree(gpio);
+		return ret;
+	}
+	pr_info("registered %s as gpio chip with #%d GPIOs.\n",
+		gpio->chip.label, gpio->chip.ngpio);
+	func->private_data = gpio;
+	return 0;
+}
+
+static void ccat_gpio_remove(struct ccat_function *func)
+{
+	struct ccat_gpio *const gpio = func->private_data;
+
+	gpiochip_remove(&gpio->chip);
+};
+
+struct ccat_driver gpio_driver = {
+	.type = CCATINFO_GPIO,
+	.probe = ccat_gpio_probe,
+	.remove = ccat_gpio_remove,
+};
diff --git a/devices/ccat/module.c b/devices/ccat/module.c
--- a/devices/ccat/module.c
+++ b/devices/ccat/module.c
@@ -1,6 +1,6 @@
 /**
     Network Driver for Beckhoff CCAT communication controller
-    Copyright (C) 2014  Beckhoff Automation GmbH
+    Copyright (C) 2014-2015  Beckhoff Automation GmbH
     Author: Patrick Bruenn <p.bruenn@beckhoff.com>
 
     This program is free software; you can redistribute it and/or modify
@@ -18,133 +18,198 @@
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 
-#include <asm/dma.h>
 #include <linux/etherdevice.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
+#include <linux/platform_device.h>
 #include <linux/version.h>
+
 #include "module.h"
-#include "netdev.h"
-#include "update.h"
 
 MODULE_DESCRIPTION(DRV_DESCRIPTION);
 MODULE_AUTHOR("Patrick Bruenn <p.bruenn@beckhoff.com>");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRV_VERSION);
 
-static void ccat_bar_free(struct ccat_bar *bar)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,27))
+/*
+ * Set both the DMA mask and the coherent DMA mask to the same thing.
+ * Note that we don't check the return value from dma_set_coherent_mask()
+ * as the DMA API guarantees that the coherent DMA mask can be set to
+ * the same or smaller than the streaming DMA mask.
+ */
+static inline int dma_set_mask_and_coherent(struct device *dev, u64 mask)
 {
-	if (bar->ioaddr) {
-		const struct ccat_bar tmp = *bar;
-		memset(bar, 0, sizeof(*bar));
-		iounmap(tmp.ioaddr);
-		release_mem_region(tmp.start, tmp.len);
-	} else {
-		pr_warn("%s(): %p was already done.\n", __FUNCTION__, bar);
-	}
+	int rc = dma_set_mask(dev, mask);
+	if (rc == 0)
+		dma_set_coherent_mask(dev, mask);
+	return rc;
 }
+#endif
 
 /**
- * ccat_bar_init() - Initialize a CCAT pci bar
- * @bar object which should be initialized
- * @index 0 and 2 are valid for CCAT, meaning pci bar0 or pci bar2
- * @pdev the pci device as which the CCAT was recognized before
- *
- * Reading PCI config space; request and map memory region.
+ * configure the drivers capabilities here
  */
-static int ccat_bar_init(struct ccat_bar *bar, size_t index,
-			 struct pci_dev *pdev)
-{
-	struct resource *res;
+static const struct ccat_driver *const drivers[] = {
+#ifdef CONFIG_PCI
+	&eth_dma_driver,	/* load Ethernet MAC/EtherCAT Master driver with DMA support from netdev.c */
+#endif
+	&eth_eim_driver,	/* load Ethernet MAC/EtherCAT Master driver without DMA support from */
+	&gpio_driver,		/* load GPIO driver from gpio.c */
+	&sram_driver,		/* load SRAM driver from sram.c */
+	&update_driver,		/* load Update driver from update.c */
+};
 
-	bar->start = pci_resource_start(pdev, index);
-	bar->end = pci_resource_end(pdev, index);
-	bar->len = pci_resource_len(pdev, index);
-	bar->flags = pci_resource_flags(pdev, index);
-	if (!(IORESOURCE_MEM & bar->flags)) {
-		pr_info("bar%llu is no mem_region -> abort.\n", (u64) index);
-		return -EIO;
-	}
+static int __init ccat_class_init(struct ccat_class *base)
+{
+	if (1 == atomic_inc_return(&base->instances)) {
+		if (alloc_chrdev_region
+		    (&base->dev, 0, base->count, KBUILD_MODNAME)) {
+			pr_warn("alloc_chrdev_region() for '%s' failed\n",
+				base->name);
+			return -1;
+		}
 
-	res = request_mem_region(bar->start, bar->len, KBUILD_MODNAME);
-	if (!res) {
-		pr_info("allocate mem_region failed.\n");
-		return -EIO;
+		base->class = class_create(THIS_MODULE, base->name);
+		if (!base->class) {
+			pr_warn("Create device class '%s' failed\n",
+				base->name);
+			unregister_chrdev_region(base->dev, base->count);
+			return -1;
+		}
 	}
-	pr_debug("bar%llu at [%lx,%lx] len=%lu res: %p.\n", (u64) index,
-		 bar->start, bar->end, bar->len, res);
-
-	bar->ioaddr = ioremap(bar->start, bar->len);
-	if (!bar->ioaddr) {
-		pr_info("bar%llu ioremap failed.\n", (u64) index);
-		release_mem_region(bar->start, bar->len);
-		return -EIO;
-	}
-	pr_debug("bar%llu I/O mem mapped to %p.\n", (u64) index, bar->ioaddr);
 	return 0;
 }
 
-void ccat_dma_free(struct ccat_dma *const dma)
+static void ccat_class_exit(struct ccat_class *base)
 {
-	const struct ccat_dma tmp = *dma;
+	if (!atomic_dec_return(&base->instances)) {
+		class_destroy(base->class);
+		unregister_chrdev_region(base->dev, base->count);
+	}
+}
 
-	free_dma(dma->channel);
-	memset(dma, 0, sizeof(*dma));
-	dma_free_coherent(tmp.dev, tmp.size, tmp.virt, tmp.phys);
+static void free_ccat_cdev(struct ccat_cdev *ccdev)
+{
+	ccat_class_exit(ccdev->class);
+	ccdev->dev = 0;
 }
 
-/**
- * ccat_dma_init() - Initialize CCAT and host memory for DMA transfer
- * @dma object for management data which will be initialized
- * @channel number of the DMA channel
- * @ioaddr of the pci bar2 configspace used to calculate the address of the pci dma configuration
- * @dev which should be configured for DMA
- */
-int ccat_dma_init(struct ccat_dma *const dma, size_t channel,
-		  void __iomem * const ioaddr, struct device *const dev)
+static struct ccat_cdev *alloc_ccat_cdev(struct ccat_class *base)
 {
-	void *frame;
-	u64 addr;
-	u32 translateAddr;
-	u32 memTranslate;
-	u32 memSize;
-	u32 data = 0xffffffff;
-	u32 offset = (sizeof(u64) * channel) + 0x1000;
+	int i = 0;
 
-	dma->channel = channel;
-	dma->dev = dev;
+	ccat_class_init(base);
+	for (i = 0; i < base->count; ++i) {
+		if (base->devices[i].dev == 0) {
+			base->devices[i].dev = MKDEV(MAJOR(base->dev), i);
+			return &base->devices[i];
+		}
+	}
+	pr_warn("exceeding max. number of '%s' devices (%d)\n",
+		base->class->name, base->count);
+	atomic_dec_return(&base->instances);
+	return NULL;
+}
 
-	/* calculate size and alignments */
-	iowrite32(data, ioaddr + offset);
-	wmb();
-	data = ioread32(ioaddr + offset);
-	memTranslate = data & 0xfffffffc;
-	memSize = (~memTranslate) + 1;
-	dma->size = 2 * memSize - PAGE_SIZE;
-	dma->virt = dma_zalloc_coherent(dev, dma->size, &dma->phys, GFP_KERNEL);
-	if (!dma->virt || !dma->phys) {
-		pr_info("init DMA%llu memory failed.\n", (u64) channel);
+static int ccat_cdev_init(struct cdev *cdev, dev_t dev, struct class *class,
+			  struct file_operations *fops)
+{
+	if (!device_create
+	    (class, NULL, dev, NULL, "%s%d", class->name, MINOR(dev))) {
+		pr_warn("device_create() failed\n");
+		return -1;
+	}
+
+	cdev_init(cdev, fops);
+	cdev->owner = fops->owner;
+	if (cdev_add(cdev, dev, 1)) {
+		pr_warn("add update device failed\n");
+		device_destroy(class, dev);
 		return -1;
 	}
 
-	if (request_dma(channel, KBUILD_MODNAME)) {
-		pr_info("request dma channel %llu failed\n", (u64) channel);
-		ccat_dma_free(dma);
-		return -1;
+	pr_info("registered %s%d.\n", class->name, MINOR(dev));
+	return 0;
+}
+
+int ccat_cdev_open(struct inode *const i, struct file *const f)
+{
+	struct ccat_cdev *ccdev =
+	    container_of(i->i_cdev, struct ccat_cdev, cdev);
+	struct cdev_buffer *buf;
+
+	if (!atomic_dec_and_test(&ccdev->in_use)) {
+		atomic_inc(&ccdev->in_use);
+		return -EBUSY;
+	}
+
+	buf = kzalloc(sizeof(*buf) + ccdev->iosize, GFP_KERNEL);
+	if (!buf) {
+		atomic_inc(&ccdev->in_use);
+		return -ENOMEM;
+	}
+
+	buf->ccdev = ccdev;
+	f->private_data = buf;
+	return 0;
+}
+
+int ccat_cdev_probe(struct ccat_function *func, struct ccat_class *cdev_class,
+		    size_t iosize)
+{
+	struct ccat_cdev *const ccdev = alloc_ccat_cdev(cdev_class);
+	if (!ccdev) {
+		return -ENOMEM;
 	}
 
-	translateAddr = (dma->phys + memSize - PAGE_SIZE) & memTranslate;
-	addr = translateAddr;
-	memcpy_toio(ioaddr + offset, &addr, sizeof(addr));
-	frame = dma->virt + translateAddr - dma->phys;
-	pr_debug
-	    ("DMA%llu mem initialized\n virt:         0x%p\n phys:         0x%llx\n translated:   0x%llx\n pci addr:     0x%08x%x\n memTranslate: 0x%x\n size:         %llu bytes.\n",
-	     (u64) channel, dma->virt, (u64) (dma->phys), addr,
-	     ioread32(ioaddr + offset + 4), ioread32(ioaddr + offset),
-	     memTranslate, (u64) dma->size);
+	ccdev->ioaddr = func->ccat->bar_0 + func->info.addr;
+	ccdev->iosize = iosize;
+	atomic_set(&ccdev->in_use, 1);
+
+	if (ccat_cdev_init
+	    (&ccdev->cdev, ccdev->dev, cdev_class->class, &cdev_class->fops)) {
+		pr_warn("ccat_cdev_probe() failed\n");
+		free_ccat_cdev(ccdev);
+		return -1;
+	}
+	ccdev->class = cdev_class;
+	func->private_data = ccdev;
+	return 0;
+}
+
+int ccat_cdev_release(struct inode *const i, struct file *const f)
+{
+	const struct cdev_buffer *const buf = f->private_data;
+	struct ccat_cdev *const ccdev = buf->ccdev;
+
+	kfree(f->private_data);
+	atomic_inc(&ccdev->in_use);
 	return 0;
 }
 
+void ccat_cdev_remove(struct ccat_function *func)
+{
+	struct ccat_cdev *const ccdev = func->private_data;
+
+	cdev_del(&ccdev->cdev);
+	device_destroy(ccdev->class->class, ccdev->dev);
+	free_ccat_cdev(ccdev);
+}
+
+static const struct ccat_driver *ccat_function_connect(struct ccat_function
+						       *const func)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(drivers); ++i) {
+		if (func->info.type == drivers[i]->type) {
+			return drivers[i]->probe(func) ? NULL : drivers[i];
+		}
+	}
+	return NULL;
+}
+
 /**
  * Initialize all available CCAT functions.
  *
@@ -153,83 +218,76 @@ int ccat_dma_init(struct ccat_dma *const
 static int ccat_functions_init(struct ccat_device *const ccatdev)
 {
 	static const size_t block_size = sizeof(struct ccat_info_block);
-	void __iomem *addr = ccatdev->bar[0].ioaddr; /** first block is the CCAT information block entry */
+	struct ccat_function *next = kzalloc(sizeof(*next), GFP_KERNEL);
+	void __iomem *addr = ccatdev->bar_0; /** first block is the CCAT information block entry */
 	const u8 num_func = ioread8(addr + 4); /** number of CCAT function blocks is at offset 0x4 */
 	const void __iomem *end = addr + (block_size * num_func);
-	int status = 0;	/** count init function failures */
 
-	while (addr < end) {
-		const u8 type = ioread16(addr);
-		switch (type) {
-		case CCATINFO_NOTUSED:
-			break;
-		case CCATINFO_EPCS_PROM:
-			pr_info("Found: CCAT update(EPCS_PROM) -> init()\n");
-			ccatdev->update = ccat_update_init(ccatdev, addr);
-			status += (NULL == ccatdev->update);
-			break;
-		case CCATINFO_ETHERCAT_MASTER_DMA:
-			pr_info("Found: ETHERCAT_MASTER_DMA -> init()\n");
-			ccatdev->ethdev = ccat_eth_init(ccatdev, addr);
-			status += (NULL == ccatdev->ethdev);
-			break;
-		default:
-			pr_info("Found: 0x%04x not supported\n", type);
-			break;
+	INIT_LIST_HEAD(&ccatdev->functions);
+	for (; addr < end && next; addr += block_size) {
+		memcpy_fromio(&next->info, addr, sizeof(next->info));
+		if (CCATINFO_NOTUSED != next->info.type) {
+			next->ccat = ccatdev;
+			next->drv = ccat_function_connect(next);
+			if (next->drv) {
+				list_add(&next->list, &ccatdev->functions);
+				next = kzalloc(sizeof(*next), GFP_KERNEL);
+			}
 		}
-		addr += block_size;
 	}
-	return status;
+	kfree(next);
+	return list_empty(&ccatdev->functions);
 }
 
 /**
  * Destroy all previously initialized CCAT functions
  */
-static void ccat_functions_remove(struct ccat_device *const ccatdev)
+static void ccat_functions_remove(struct ccat_device *const dev)
 {
-	if (!ccatdev->ethdev) {
-		pr_warn("%s(): 'ethdev' was not initialized.\n", __FUNCTION__);
-	} else {
-		struct ccat_eth_priv *const ethdev = ccatdev->ethdev;
-		ccatdev->ethdev = NULL;
-		ccat_eth_remove(ethdev);
-	}
-	if (!ccatdev->update) {
-		pr_warn("%s(): 'update' was not initialized.\n", __FUNCTION__);
-	} else {
-		struct ccat_update *const update = ccatdev->update;
-		ccatdev->update = NULL;
-		ccat_update_remove(update);
+	struct ccat_function *func;
+	struct ccat_function *tmp;
+	list_for_each_entry_safe(func, tmp, &dev->functions, list) {
+		if (func->drv) {
+			func->drv->remove(func);
+			func->drv = NULL;
+		}
+		list_del(&func->list);
+		kfree(func);
 	}
 }
 
-static int ccat_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+#ifdef CONFIG_PCI
+static int ccat_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
+	struct ccat_device *ccatdev;
+	u8 revision;
 	int status;
-	u8 revision;
-	struct ccat_device *ccatdev = kmalloc(sizeof(*ccatdev), GFP_KERNEL);
 
+	ccatdev = devm_kzalloc(&pdev->dev, sizeof(*ccatdev), GFP_KERNEL);
 	if (!ccatdev) {
 		pr_err("%s() out of memory.\n", __FUNCTION__);
 		return -ENOMEM;
 	}
-	memset(ccatdev, 0, sizeof(*ccatdev));
 	ccatdev->pdev = pdev;
 	pci_set_drvdata(pdev, ccatdev);
 
 	status = pci_enable_device_mem(pdev);
 	if (status) {
 		pr_info("enable %s failed: %d\n", pdev->dev.kobj.name, status);
-		return status;
+		goto cleanup_pci_device;
 	}
 
 	status = pci_read_config_byte(pdev, PCI_REVISION_ID, &revision);
 	if (status) {
 		pr_warn("read CCAT pci revision failed with %d\n", status);
-		return status;
+		goto cleanup_pci_device;
 	}
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	if ((status = pci_request_regions(pdev, KBUILD_MODNAME))) {
+		pr_info("allocate mem_regions failed.\n");
+		goto cleanup_pci_device;
+	}
+
 	if (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {
 		pr_debug("64 bit DMA supported, pci rev: %u\n", revision);
 	} else if (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32))) {
@@ -237,24 +295,15 @@ static int ccat_probe(struct pci_dev *pd
 	} else {
 		pr_warn("No suitable DMA available, pci rev: %u\n", revision);
 	}
-#else
-	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {
-		pr_debug("64 bit DMA supported, pci rev: %u\n", revision);
-	} else if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
-		pr_debug("32 bit DMA supported, pci rev: %u\n", revision);
-	} else {
-		pr_warn("No suitable DMA available, pci rev: %u\n", revision);
-	}
-#endif
 
-	if (ccat_bar_init(&ccatdev->bar[0], 0, pdev)) {
+	if (!(ccatdev->bar_0 = pci_iomap(pdev, 0, 0))) {
 		pr_warn("initialization of bar0 failed.\n");
-		return -EIO;
+		status = -EIO;
+		goto cleanup_pci_device;
 	}
 
-	if (ccat_bar_init(&ccatdev->bar[2], 2, pdev)) {
-		pr_warn("initialization of bar2 failed.\n");
-		return -EIO;
+	if (!(ccatdev->bar_2 = pci_iomap(pdev, 2, 0))) {
+		pr_warn("initialization of optional bar2 failed.\n");
 	}
 
 	pci_set_master(pdev);
@@ -262,21 +311,23 @@ static int ccat_probe(struct pci_dev *pd
 		pr_warn("some functions couldn't be initialized\n");
 	}
 	return 0;
+cleanup_pci_device:
+	pci_disable_device(pdev);
+	return status;
 }
 
-static void ccat_remove(struct pci_dev *pdev)
+static void ccat_pci_remove(struct pci_dev *pdev)
 {
 	struct ccat_device *ccatdev = pci_get_drvdata(pdev);
 
 	if (ccatdev) {
 		ccat_functions_remove(ccatdev);
-		ccat_bar_free(&ccatdev->bar[2]);
-		ccat_bar_free(&ccatdev->bar[0]);
+		if (ccatdev->bar_2)
+			pci_iounmap(pdev, ccatdev->bar_2);
+		pci_iounmap(pdev, ccatdev->bar_0);
+		pci_release_regions(pdev);
 		pci_disable_device(pdev);
-		pci_set_drvdata(pdev, NULL);
-		kfree(ccatdev);
 	}
-	pr_debug("%s() done.\n", __FUNCTION__);
 }
 
 #define PCI_DEVICE_ID_BECKHOFF_CCAT 0x5000
@@ -287,27 +338,76 @@ static const struct pci_device_id pci_id
 	{0,},
 };
 
-#if 0 /* prevent auto-loading */
 MODULE_DEVICE_TABLE(pci, pci_ids);
-#endif
 
-static struct pci_driver pci_driver = {
+static struct pci_driver ccat_pci_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = pci_ids,
-	.probe = ccat_probe,
-	.remove = ccat_remove,
+	.probe = ccat_pci_probe,
+	.remove = ccat_pci_remove,
 };
 
-static void __exit ccat_exit_module(void)
+module_pci_driver(ccat_pci_driver);
+
+#else /* #ifdef CONFIG_PCI */
+
+static int ccat_eim_probe(struct platform_device *pdev)
 {
-	pci_unregister_driver(&pci_driver);
+	struct ccat_device *ccatdev;
+
+	ccatdev = devm_kzalloc(&pdev->dev, sizeof(*ccatdev), GFP_KERNEL);
+	if (!ccatdev) {
+		pr_err("%s() out of memory.\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	ccatdev->pdev = pdev;
+	platform_set_drvdata(pdev, ccatdev);
+
+	if (!request_mem_region(0xf0000000, 0x02000000, pdev->name)) {
+		pr_warn("request mem region failed.\n");
+		return -EIO;
+	}
+
+	if (!(ccatdev->bar_0 = ioremap(0xf0000000, 0x02000000))) {
+		pr_warn("initialization of bar0 failed.\n");
+		return -EIO;
+	}
+
+	ccatdev->bar_2 = NULL;
+
+	if (ccat_functions_init(ccatdev)) {
+		pr_warn("some functions couldn't be initialized\n");
+	}
+	return 0;
 }
 
-static int __init ccat_init_module(void)
+static int ccat_eim_remove(struct platform_device *pdev)
 {
-	pr_info("%s, %s\n", DRV_DESCRIPTION, DRV_VERSION);
-	return pci_register_driver(&pci_driver);
+	struct ccat_device *ccatdev = platform_get_drvdata(pdev);
+
+	if (ccatdev) {
+		ccat_functions_remove(ccatdev);
+		iounmap(ccatdev->bar_0);
+		release_mem_region(0xf0000000, 0x02000000);
+	}
+	return 0;
 }
 
-module_exit(ccat_exit_module);
-module_init(ccat_init_module);
+static const struct of_device_id bhf_eim_ccat_ids[] = {
+	{.compatible = "bhf,emi-ccat",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, bhf_eim_ccat_ids);
+
+static struct platform_driver ccat_eim_driver = {
+	.driver = {
+		   .name = KBUILD_MODNAME,
+		   .of_match_table = bhf_eim_ccat_ids,
+		   },
+	.probe = ccat_eim_probe,
+	.remove = ccat_eim_remove,
+};
+
+module_platform_driver(ccat_eim_driver);
+#endif /* #ifdef CONFIG_PCI */
diff --git a/devices/ccat/module.h b/devices/ccat/module.h
--- a/devices/ccat/module.h
+++ b/devices/ccat/module.h
@@ -22,140 +22,76 @@
 #define _CCAT_H_
 
 #include <linux/cdev.h>
+#include <linux/fs.h>
 #include <linux/hrtimer.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include "../ecdev.h"
 
 #define DRV_EXTRAVERSION "-ec"
-#define DRV_VERSION      "0.10" DRV_EXTRAVERSION
+#define DRV_VERSION      "0.13" DRV_EXTRAVERSION
 #define DRV_DESCRIPTION  "Beckhoff CCAT Ethernet/EtherCAT Network Driver"
 
 #undef pr_fmt
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+extern struct ccat_driver eth_eim_driver;
+extern struct ccat_driver eth_dma_driver;
+extern struct ccat_driver gpio_driver;
+extern struct ccat_driver sram_driver;
+extern struct ccat_driver update_driver;
+
 /**
  * CCAT function type identifiers (u16)
  */
 enum ccat_info_t {
 	CCATINFO_NOTUSED = 0,
+	CCATINFO_ETHERCAT_NODMA = 0x3,
+	CCATINFO_GPIO = 0xd,
 	CCATINFO_EPCS_PROM = 0xf,
 	CCATINFO_ETHERCAT_MASTER_DMA = 0x14,
-	CCATINFO_COPY_BLOCK = 0x17,
-	CCATINFO_MAX
+	CCATINFO_SRAM = 0x16,
 };
 
-/**
- * struct ccat_bar - CCAT PCI Base Address Register(BAR) configuration
- * @start: start address of this BAR
- * @end: end address of this BAR
- * @len: length of this BAR
- * @flags: flags set on this BAR
- * @ioaddr: ioremapped address of this bar
- */
-struct ccat_bar {
-	unsigned long start;
-	unsigned long end;
-	unsigned long len;
-	unsigned long flags;
+struct ccat_cdev {
+	atomic_t in_use;
 	void __iomem *ioaddr;
+	size_t iosize;
+	dev_t dev;
+	struct cdev cdev;
+	struct ccat_class *class;
 };
 
 /**
- * struct ccat_dma - CCAT DMA channel configuration
- * @phys: device-viewed address(physical) of the associated DMA memory
- * @virt: CPU-viewed address(virtual) of the associated DMA memory
- * @size: number of bytes in the associated DMA memory
- * @channel: CCAT DMA channel number
- * @dev: valid struct device pointer
+ * struct cdev_buffer
+ * @ccdev: referenced character device
+ * @data: buffer used for write operations
+ * @size: number of bytes written to the data buffer
  */
-struct ccat_dma {
-	dma_addr_t phys;
-	void *virt;
+struct cdev_buffer {
+	struct ccat_cdev *ccdev;
 	size_t size;
-	size_t channel;
-	struct device *dev;
+	char data[];
 };
 
-extern void ccat_dma_free(struct ccat_dma *const dma);
-extern int ccat_dma_init(struct ccat_dma *const dma, size_t channel,
-			 void __iomem * const ioaddr, struct device *const dev);
-
-/**
- * struct ccat_eth_frame - Ethernet frame with DMA descriptor header in front
- * @reservedn: is not used and should always be set to 0
- * @received: used for reception, is set to 1 by the CCAT when data was written
- * @length: number of bytes in the frame including the DMA header
- * @sent: is set to 1 by the CCAT when data was transmitted
- * @timestamp: a 64 bit EtherCAT timestamp
- * @data: the bytes of the ethernet frame
- */
-struct ccat_eth_frame {
-	__le32 reserved1;
-	__le32 rx_flags;
-#define CCAT_FRAME_RECEIVED 0x1
-	__le16 length;
-	__le16 reserved3;
-	__le32 tx_flags;
-#define CCAT_FRAME_SENT 0x1
-	__le64 timestamp;
-	u8 data[0x800 - 3 * sizeof(u64)];
-#define CCAT_ETH_FRAME_HEAD_LEN offsetof(struct ccat_eth_frame, data)
-};
-
-/**
- * struct ccat_eth_register - CCAT register addresses in the PCI BAR
- * @mii: address of the CCAT management interface register
- * @tx_fifo: address of the CCAT TX DMA fifo register
- * @rx_fifo: address of the CCAT RX DMA fifo register
- * @mac: address of the CCAT media access control register
- * @rx_mem: address of the CCAT register holding the RX DMA address
- * @tx_mem: address of the CCAT register holding the TX DMA address
- * @misc: address of a CCAT register holding miscellaneous information
- */
-struct ccat_eth_register {
-	void __iomem *mii;
-	void __iomem *tx_fifo;
-	void __iomem *rx_fifo;
-	void __iomem *mac;
-	void __iomem *rx_mem;
-	void __iomem *tx_mem;
-	void __iomem *misc;
-};
-
-/**
- * struct ccat_eth_dma_fifo - CCAT RX or TX DMA fifo
- * @add: callback used to add a frame to this fifo
- * @reg: PCI register address of this DMA fifo
- * @dma: information about the associated DMA memory
- */
-struct ccat_eth_dma_fifo {
-	void (*add) (struct ccat_eth_dma_fifo *, struct ccat_eth_frame *);
-	void __iomem *reg;
-	const struct ccat_eth_frame *end;
-	struct ccat_eth_frame *next;
-	struct ccat_dma dma;
-};
+extern int ccat_cdev_open(struct inode *const i, struct file *const f);
+extern int ccat_cdev_release(struct inode *const i, struct file *const f);
 
 /**
  * struct ccat_device - CCAT device representation
  * @pdev: pointer to the pci object allocated by the kernel
- * @ethdev: CCAT Ethernet/EtherCAT Master (with DMA) function, NULL if function is not available or failed to initialize
- * @update: CCAT Update function, NULL if function is not available or failed to initialize
- * @bar [0] and [2] holding information about PCI BARs 0 and 2.
+ * @bar_0: holding information about PCI BAR 0
+ * @bar_2: holding information about PCI BAR 2 (optional)
+ * @functions: list of available (driver loaded) FPGA functions
  *
  * One instance of a ccat_device should represent a physical CCAT. Since
- * a CCAT is implemented as FPGA the available functions can vary so
- * the function object pointers can be NULL.
- * Extra note: you will recognize that PCI BAR1 is not used and is a
- * waste of memory, thats true but right now, its very easy to use it
- * this way. So we might optimize it later.
+ * a CCAT is implemented as FPGA the available functions can vary.
  */
 struct ccat_device {
-	struct pci_dev *pdev;
-	struct ccat_eth_priv *ethdev;
-	struct ccat_update *update;
-	struct ccat_bar bar[3];	//TODO optimize this
+	void *pdev;
+	void __iomem *bar_0;
+	void __iomem *bar_2;
+	struct list_head functions;
 };
 
 struct ccat_info_block {
@@ -163,106 +99,59 @@ struct ccat_info_block {
 	u16 rev;
 	union {
 		u32 config;
+		u8 num_gpios;
+		struct {
+			u16 tx_size;
+			u16 rx_size;
+		};
 		struct {
 			u8 tx_dma_chan;
 			u8 rx_dma_chan;
 		};
+		struct {
+			u8 sram_width;
+			u8 sram_size;
+			u16 reserved;
+		};
 	};
 	u32 addr;
 	u32 size;
 };
 
-/**
- * struct ccat_eth_priv - CCAT Ethernet/EtherCAT Master function (netdev)
- * @ccatdev: pointer to the parent struct ccat_device
- * @netdev: the net_device structure used by the kernel networking stack
- * @info: holds a copy of the CCAT Ethernet/EtherCAT Master function information block (read from PCI config space)
- * @reg: register addresses in PCI config space of the Ethernet/EtherCAT Master function
- * @rx_fifo: DMA fifo used for RX DMA descriptors
- * @tx_fifo: DMA fifo used for TX DMA descriptors
- * @poll_timer: interval timer used to poll CCAT for events like link changed, rx done, tx done
- * @rx_bytes: number of bytes received -> reported with ndo_get_stats64()
- * @rx_dropped: number of received frames, which were dropped -> reported with ndo_get_stats64()
- * @tx_bytes: number of bytes send -> reported with ndo_get_stats64()
- * @tx_dropped: number of frames requested to send, which were dropped -> reported with ndo_get_stats64()
- */
-struct ccat_eth_priv {
-	const struct ccat_device *ccatdev;
-	struct net_device *netdev;
+struct ccat_function {
+	const struct ccat_driver *drv;
+	struct ccat_device *ccat;
 	struct ccat_info_block info;
-	struct ccat_eth_register reg;
-	struct ccat_eth_dma_fifo rx_fifo;
-	struct ccat_eth_dma_fifo tx_fifo;
-	struct hrtimer poll_timer;
-	atomic64_t rx_bytes;
-	atomic64_t rx_dropped;
-	atomic64_t tx_bytes;
-	atomic64_t tx_dropped;
-	ec_device_t *ecdev;
-	void (*carrier_off) (struct net_device * netdev);
-	bool (*carrier_ok) (const struct net_device * netdev);
-	void (*carrier_on) (struct net_device * netdev);
-	void (*kfree_skb_any) (struct sk_buff * skb);
-	void (*start_queue) (struct net_device * netdev);
-	void (*stop_queue) (struct net_device * netdev);
-	void (*unregister) (struct net_device * netdev);
+	struct list_head list;
+	void *private_data;
 };
 
+struct ccat_class {
+	dev_t dev;
+	struct class *class;
+	atomic_t instances;
+	const unsigned count;
+	struct ccat_cdev *devices;
+	const char *name;
+	struct file_operations fops;
+};
+
+extern void ccat_cdev_remove(struct ccat_function *func);
+extern int ccat_cdev_probe(struct ccat_function *func,
+			   struct ccat_class *cdev_class, size_t iosize);
+
 /**
- * same as: typedef struct _CCatInfoBlockOffs from CCatDefinitions.h
- * TODO add some checking facility outside of the linux tree
+ * struct ccat_driver - CCAT FPGA function
+ * @probe: add device instance
+ * @remove: remove device instance
+ * @type: type of the FPGA function supported by this driver
+ * @cdev_class: if not NULL that driver supports ccat_class_init()/_exit()
  */
-struct ccat_mac_infoblock {
-	u32 reserved;
-	u32 mii;
-	u32 tx_fifo;
-	u32 mac;
-	u32 rx_mem;
-	u32 tx_mem;
-	u32 misc;
+struct ccat_driver {
+	int (*probe) (struct ccat_function * func);
+	void (*remove) (struct ccat_function * drv);
+	enum ccat_info_t type;
+	struct ccat_class *cdev_class;
 };
 
-struct ccat_mac_register {
-	/** MAC error register     @+0x0 */
-	u8 frame_len_err;
-	u8 rx_err;
-	u8 crc_err;
-	u8 link_lost_err;
-	u32 reserved1;
-	/** Buffer overflow errors @+0x8 */
-	u8 rx_mem_full;
-	u8 reserved2[7];
-	/** MAC frame counter      @+0x10 */
-	u32 tx_frames;
-	u32 rx_frames;
-	u64 reserved3;
-	/** MAC fifo level         @+0x20 */
-	u8 tx_fifo_level:7;
-	u8 reserved4:1;
-	u8 reserved5[7];
-	/** TX memory full error   @+0x28 */
-	u8 tx_mem_full;
-	u8 reserved6[7];
-	u64 reserved8[9];
-	/** Connection             @+0x78 */
-	u8 mii_connected;
-};
-
-/**
- * struct ccat_update - CCAT Update function (update)
- * @ccatdev: pointer to the parent struct ccat_device
- * @ioaddr: PCI base address of the CCAT Update function
- * dev: device number for this update function
- * cdev: character device used for the CCAT Update function
- * class: pointer to a device class used when registering the CCAT Update device
- * @info: holds a copy of the CCAT Update function information block (read from PCI config space)
- */
-struct ccat_update {
-	struct kref refcount;
-	void __iomem *ioaddr;
-	dev_t dev;
-	struct cdev cdev;
-	struct class *class;
-	struct ccat_info_block info;
-};
 #endif /* #ifndef _CCAT_H_ */
diff --git a/devices/ccat/netdev.c b/devices/ccat/netdev.c
--- a/devices/ccat/netdev.c
+++ b/devices/ccat/netdev.c
@@ -1,6 +1,6 @@
 /**
     Network Driver for Beckhoff CCAT communication controller
-    Copyright (C) 2014  Beckhoff Automation GmbH
+    Copyright (C) 2014 - 2015  Beckhoff Automation GmbH
     Author: Patrick Bruenn <p.bruenn@beckhoff.com>
 
     This program is free software; you can redistribute it and/or modify
@@ -23,8 +23,14 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 
+#ifdef CONFIG_PCI
+#include <asm/dma.h>
+#else
+#define free_dma(X)
+#define request_dma(X, Y) ((int)(-EINVAL))
+#endif
+
 #include "module.h"
-#include "netdev.h"
 
 /**
  * EtherCAT frame to enable forwarding on EtherCAT Terminals
@@ -44,23 +50,250 @@ static const u8 frameForwardEthernetFram
 };
 
 #define FIFO_LENGTH 64
-#define POLL_TIME ktime_set(0, 100 * NSEC_PER_USEC)
+#define POLL_TIME ktime_set(0, 50 * NSEC_PER_USEC)
+
+struct ccat_dma_frame_hdr {
+	__le32 reserved1;
+	__le32 rx_flags;
+#define CCAT_FRAME_RECEIVED 0x1
+	__le16 length;
+	__le16 reserved3;
+	__le32 tx_flags;
+#define CCAT_FRAME_SENT 0x1
+	__le64 timestamp;
+};
+
+struct ccat_eim_frame_hdr {
+	__le16 length;
+	__le16 reserved3;
+	__le32 tx_flags;
+	__le64 timestamp;
+};
+
+struct ccat_eth_frame {
+	u8 placeholder[0x800];
+};
+
+struct ccat_dma_frame {
+	struct ccat_dma_frame_hdr hdr;
+	u8 data[sizeof(struct ccat_eth_frame) -
+		sizeof(struct ccat_dma_frame_hdr)];
+};
+
+struct ccat_eim_frame {
+	struct ccat_eim_frame_hdr hdr;
+	u8 data[sizeof(struct ccat_eth_frame) -
+		sizeof(struct ccat_eim_frame_hdr)];
+};
+
+#define MAX_PAYLOAD_SIZE \
+	(sizeof(struct ccat_eth_frame) - max(sizeof(struct ccat_dma_frame_hdr), sizeof(struct ccat_eim_frame_hdr)))
+
+/**
+ * struct ccat_eth_register - CCAT register addresses in the PCI BAR
+ * @mii: address of the CCAT management interface register
+ * @tx_fifo: address of the CCAT TX DMA fifo register
+ * @rx_fifo: address of the CCAT RX DMA fifo register
+ * @mac: address of the CCAT media access control register
+ * @rx_mem: address of the CCAT register holding the RX DMA address
+ * @tx_mem: address of the CCAT register holding the TX DMA address
+ * @misc: address of a CCAT register holding miscellaneous information
+ */
+struct ccat_eth_register {
+	void __iomem *mii;
+	void __iomem *tx_fifo;
+	void __iomem *rx_fifo;
+	void __iomem *mac;
+	void __iomem *rx_mem;
+	void __iomem *tx_mem;
+	void __iomem *misc;
+};
+
+/**
+ * struct ccat_dma - CCAT DMA channel configuration
+ * @phys: device-viewed address(physical) of the associated DMA memory
+ * @start: CPU-viewed address(virtual) of the associated DMA memory
+ * @size: number of bytes in the associated DMA memory
+ * @channel: CCAT DMA channel number
+ * @dev: valid struct device pointer
+ */
+struct ccat_dma {
+	struct ccat_dma_frame *next;
+	void *start;
+	size_t size;
+	dma_addr_t phys;
+	size_t channel;
+	struct device *dev;
+};
+
+struct ccat_eim {
+	struct ccat_eim_frame __iomem *next;
+	void __iomem *start;
+	size_t size;
+};
+
+struct ccat_mem {
+	struct ccat_eth_frame *next;
+	void *start;
+};
 
 /**
- * Helper to check if frame in tx dma memory was already marked as sent by CCAT
+ * struct ccat_eth_fifo - CCAT RX or TX DMA fifo
+ * @add: callback used to add a frame to this fifo
+ * @reg: PCI register address of this DMA fifo
+ * @dma: information about the associated DMA memory
+ */
+struct ccat_eth_fifo {
+	void (*add) (struct ccat_eth_fifo *);
+	void (*copy_to_skb) (struct ccat_eth_fifo *, struct sk_buff *, size_t);
+	void (*queue_skb) (struct ccat_eth_fifo * const, struct sk_buff *);
+	void __iomem *reg;
+	const struct ccat_eth_frame *end;
+	union {
+		struct ccat_mem mem;
+		struct ccat_dma dma;
+		struct ccat_eim eim;
+	};
+};
+
+/**
+ * same as: typedef struct _CCatInfoBlockOffs from CCatDefinitions.h
+ */
+struct ccat_mac_infoblock {
+	u32 reserved;
+	u32 mii;
+	u32 tx_fifo;
+	u32 mac;
+	u32 rx_mem;
+	u32 tx_mem;
+	u32 misc;
+};
+
+/**
+ * struct ccat_eth_priv - CCAT Ethernet/EtherCAT Master function (netdev)
+ * @func: pointer to the parent struct ccat_function
+ * @netdev: the net_device structure used by the kernel networking stack
+ * @info: holds a copy of the CCAT Ethernet/EtherCAT Master function information block (read from PCI config space)
+ * @reg: register addresses in PCI config space of the Ethernet/EtherCAT Master function
+ * @rx_fifo: DMA fifo used for RX DMA descriptors
+ * @tx_fifo: DMA fifo used for TX DMA descriptors
+ * @poll_timer: interval timer used to poll CCAT for events like link changed, rx done, tx done
+ * @rx_bytes: number of bytes received -> reported with ndo_get_stats64()
+ * @rx_dropped: number of received frames, which were dropped -> reported with ndo_get_stats64()
+ * @tx_bytes: number of bytes send -> reported with ndo_get_stats64()
+ * @tx_dropped: number of frames requested to send, which were dropped -> reported with ndo_get_stats64()
  */
-static inline bool ccat_eth_frame_sent(const struct ccat_eth_frame *const frame)
+struct ccat_eth_priv {
+	void (*free) (struct ccat_eth_priv *);
+	 bool(*tx_ready) (const struct ccat_eth_priv *);
+	 size_t(*rx_ready) (struct ccat_eth_fifo *);
+	struct ccat_function *func;
+	struct net_device *netdev;
+	struct ccat_eth_register reg;
+	struct ccat_eth_fifo rx_fifo;
+	struct ccat_eth_fifo tx_fifo;
+	struct hrtimer poll_timer;
+	atomic64_t rx_bytes;
+	atomic64_t rx_dropped;
+	atomic64_t tx_bytes;
+	atomic64_t tx_dropped;
+	ec_device_t *ecdev;
+	void (*carrier_off) (struct net_device * netdev);
+	 bool(*carrier_ok) (const struct net_device * netdev);
+	void (*carrier_on) (struct net_device * netdev);
+	void (*kfree_skb_any) (struct sk_buff * skb);
+	void (*receive) (struct ccat_eth_priv *, size_t);
+	void (*start_queue) (struct net_device * netdev);
+	void (*stop_queue) (struct net_device * netdev);
+	void (*unregister) (struct net_device * netdev);
+};
+
+struct ccat_mac_register {
+	/** MAC error register     @+0x0 */
+	u8 frame_len_err;
+	u8 rx_err;
+	u8 crc_err;
+	u8 link_lost_err;
+	u32 reserved1;
+	/** Buffer overflow errors @+0x8 */
+	u8 rx_mem_full;
+	u8 reserved2[7];
+	/** MAC frame counter      @+0x10 */
+	u32 tx_frames;
+	u32 rx_frames;
+	u64 reserved3;
+	/** MAC fifo level         @+0x20 */
+	u8 tx_fifo_level:7;
+	u8 reserved4:1;
+	u8 reserved5[7];
+	/** TX memory full error   @+0x28 */
+	u8 tx_mem_full;
+	u8 reserved6[7];
+	u64 reserved8[9];
+	/** Connection             @+0x78 */
+	u8 mii_connected;
+};
+
+static void ccat_dma_free(struct ccat_dma *const dma)
 {
-	return le32_to_cpu(frame->tx_flags) & CCAT_FRAME_SENT;
+	const struct ccat_dma tmp = *dma;
+
+	free_dma(dma->channel);
+	memset(dma, 0, sizeof(*dma));
+	dma_free_coherent(tmp.dev, tmp.size, tmp.start, tmp.phys);
 }
 
 /**
- * Helper to check if frame in tx dma memory was already marked as sent by CCAT
+ * ccat_dma_init() - Initialize CCAT and host memory for DMA transfer
+ * @dma object for management data which will be initialized
+ * @channel number of the DMA channel
+ * @ioaddr of the pci bar2 configspace used to calculate the address of the pci dma configuration
+ * @dev which should be configured for DMA
  */
-static inline bool ccat_eth_frame_received(const struct ccat_eth_frame *const
-					   frame)
+static int ccat_dma_init(struct ccat_dma *const dma, size_t channel,
+			 void __iomem * const ioaddr, struct device *const dev)
 {
-	return le32_to_cpu(frame->rx_flags) & CCAT_FRAME_RECEIVED;
+	void *frame;
+	u64 addr;
+	u32 translateAddr;
+	u32 memTranslate;
+	u32 memSize;
+	u32 data = 0xffffffff;
+	u32 offset = (sizeof(u64) * channel) + 0x1000;
+
+	dma->channel = channel;
+	dma->dev = dev;
+
+	/* calculate size and alignments */
+	iowrite32(data, ioaddr + offset);
+	wmb();
+	data = ioread32(ioaddr + offset);
+	memTranslate = data & 0xfffffffc;
+	memSize = (~memTranslate) + 1;
+	dma->size = 2 * memSize - PAGE_SIZE;
+	dma->start =
+	    dma_zalloc_coherent(dev, dma->size, &dma->phys, GFP_KERNEL);
+	if (!dma->start || !dma->phys) {
+		pr_info("init DMA%llu memory failed.\n", (u64) channel);
+		return -ENOMEM;
+	}
+
+	if (request_dma(channel, KBUILD_MODNAME)) {
+		pr_info("request dma channel %llu failed\n", (u64) channel);
+		ccat_dma_free(dma);
+		return -EINVAL;
+	}
+
+	translateAddr = (dma->phys + memSize - PAGE_SIZE) & memTranslate;
+	addr = translateAddr;
+	memcpy_toio(ioaddr + offset, &addr, sizeof(addr));
+	frame = dma->start + translateAddr - dma->phys;
+	pr_debug
+	    ("DMA%llu mem initialized\n start:         0x%p\n phys:         0x%llx\n translated:   0x%llx\n pci addr:     0x%08x%x\n memTranslate: 0x%x\n size:         %llu bytes.\n",
+	     (u64) channel, dma->start, (u64) (dma->phys), addr,
+	     ioread32(ioaddr + offset + 4), ioread32(ioaddr + offset),
+	     memTranslate, (u64) dma->size);
+	return 0;
 }
 
 static void ecdev_kfree_skb_any(struct sk_buff *skb)
@@ -91,6 +324,16 @@ static void ecdev_nop(struct net_device 
 	/* dummy called if nothing has to be done in EtherCAT operation mode */
 }
 
+static void ecdev_receive_dma(struct ccat_eth_priv *const priv, size_t len)
+{
+	ecdev_receive(priv->ecdev, priv->rx_fifo.dma.next->data, len);
+}
+
+static void ecdev_receive_eim(struct ccat_eth_priv *const priv, size_t len)
+{
+	ecdev_receive(priv->ecdev, priv->rx_fifo.eim.next->data, len);
+}
+
 static void unregister_ecdev(struct net_device *const netdev)
 {
 	struct ccat_eth_priv *const priv = netdev_priv(netdev);
@@ -98,67 +341,145 @@ static void unregister_ecdev(struct net_
 	ecdev_withdraw(priv->ecdev);
 }
 
-static void ccat_eth_fifo_inc(struct ccat_eth_dma_fifo *fifo)
+static inline bool fifo_eim_tx_ready(const struct ccat_eth_priv *const priv)
+{
+	static const size_t TX_FIFO_LEVEL_OFFSET = 0x20;
+	static const u8 TX_FIFO_LEVEL_MASK = 0x3F;
+	void __iomem *addr = priv->reg.mac + TX_FIFO_LEVEL_OFFSET;
+
+	return !(ioread8(addr) & TX_FIFO_LEVEL_MASK);
+}
+
+static inline size_t fifo_eim_rx_ready(struct ccat_eth_fifo *const fifo)
 {
-	if (++fifo->next >= fifo->end)
-		fifo->next = fifo->dma.virt;
+	static const size_t OVERHEAD = sizeof(struct ccat_eim_frame_hdr);
+	const size_t len = ioread16(&fifo->eim.next->hdr.length);
+
+	return (len < OVERHEAD) ? 0 : len - OVERHEAD;
+}
+
+static void ccat_eth_fifo_inc(struct ccat_eth_fifo *fifo)
+{
+	if (++fifo->mem.next > fifo->end)
+		fifo->mem.next = fifo->mem.start;
 }
 
-typedef void (*fifo_add_function) (struct ccat_eth_dma_fifo *,
-				   struct ccat_eth_frame *);
+static void fifo_eim_rx_add(struct ccat_eth_fifo *const fifo)
+{
+	struct ccat_eim_frame __iomem *frame = fifo->eim.next;
+	iowrite16(0, frame);
+	wmb();
+}
+
+static void fifo_eim_tx_add(struct ccat_eth_fifo *const fifo)
+{
+}
 
-static void ccat_eth_rx_fifo_add(struct ccat_eth_dma_fifo *fifo,
-				 struct ccat_eth_frame *frame)
+#define memcpy_from_ccat(DEST, SRC, LEN) memcpy(DEST,(__force void*)(SRC), LEN)
+#define memcpy_to_ccat(DEST, SRC, LEN) memcpy((__force void*)(DEST),SRC, LEN)
+static void fifo_eim_copy_to_linear_skb(struct ccat_eth_fifo *const fifo,
+					struct sk_buff *skb, const size_t len)
 {
-	const size_t offset = ((void *)(frame) - fifo->dma.virt);
-	const u32 addr_and_length = (1 << 31) | offset;
+	memcpy_from_ccat(skb->data, fifo->eim.next->data, len);
+}
 
-	frame->rx_flags = cpu_to_le32(0);
+static void fifo_eim_queue_skb(struct ccat_eth_fifo *const fifo,
+			       struct sk_buff *skb)
+{
+	struct ccat_eim_frame __iomem *frame = fifo->eim.next;
+	const u32 addr_and_length =
+	    (void __iomem *)frame - (void __iomem *)fifo->eim.start;
+
+	const __le16 length = cpu_to_le16(skb->len);
+	memcpy_to_ccat(&frame->hdr.length, &length, sizeof(length));
+	memcpy_to_ccat(frame->data, skb->data, skb->len);
 	iowrite32(addr_and_length, fifo->reg);
 }
 
-static void ccat_eth_tx_fifo_add_free(struct ccat_eth_dma_fifo *fifo,
-				      struct ccat_eth_frame *frame)
+static void ccat_eth_priv_free_eim(struct ccat_eth_priv *priv)
 {
-	/* mark frame as ready to use for tx */
-	frame->tx_flags = cpu_to_le32(CCAT_FRAME_SENT);
+	/* reset hw fifo's */
+	iowrite32(0, priv->tx_fifo.reg + 0x8);
+	wmb();
 }
 
-static void ccat_eth_dma_fifo_reset(struct ccat_eth_dma_fifo *fifo)
+static void ccat_eth_fifo_reset(struct ccat_eth_fifo *const fifo)
 {
 	/* reset hw fifo */
-	iowrite32(0, fifo->reg + 0x8);
-	wmb();
+	if (fifo->reg) {
+		iowrite32(0, fifo->reg + 0x8);
+		wmb();
+	}
 
 	if (fifo->add) {
-		fifo->next = fifo->dma.virt;
+		fifo->mem.next = fifo->mem.start;
 		do {
-			fifo->add(fifo, fifo->next);
+			fifo->add(fifo);
 			ccat_eth_fifo_inc(fifo);
-		} while (fifo->next != fifo->dma.virt);
+		} while (fifo->mem.next != fifo->mem.start);
 	}
 }
 
-static int ccat_eth_dma_fifo_init(struct ccat_eth_dma_fifo *fifo,
-				  void __iomem * const fifo_reg,
-				  fifo_add_function add, size_t channel,
-				  struct ccat_eth_priv *const priv)
+static inline bool fifo_dma_tx_ready(const struct ccat_eth_priv *const priv)
+{
+	const struct ccat_dma_frame *frame = priv->tx_fifo.dma.next;
+	return le32_to_cpu(frame->hdr.tx_flags) & CCAT_FRAME_SENT;
+}
+
+static inline size_t fifo_dma_rx_ready(struct ccat_eth_fifo *const fifo)
 {
-	if (0 !=
-	    ccat_dma_init(&fifo->dma, channel, priv->ccatdev->bar[2].ioaddr,
-			  &priv->ccatdev->pdev->dev)) {
-		pr_info("init DMA%llu memory failed.\n", (u64) channel);
-		return -1;
+	static const size_t OVERHEAD =
+	    offsetof(struct ccat_dma_frame_hdr, rx_flags);
+	const struct ccat_dma_frame *const frame = fifo->dma.next;
+
+	if (le32_to_cpu(frame->hdr.rx_flags) & CCAT_FRAME_RECEIVED) {
+		const size_t len = le16_to_cpu(frame->hdr.length);
+		return (len < OVERHEAD) ? 0 : len - OVERHEAD;
 	}
-	fifo->add = add;
-	fifo->end = ((struct ccat_eth_frame *)fifo->dma.virt) + FIFO_LENGTH;
-	fifo->reg = fifo_reg;
 	return 0;
 }
 
-/**
- * Stop both (Rx/Tx) DMA fifo's and free related management structures
- */
+static void ccat_eth_rx_fifo_dma_add(struct ccat_eth_fifo *const fifo)
+{
+	struct ccat_dma_frame *const frame = fifo->dma.next;
+	const size_t offset = (void *)frame - fifo->dma.start;
+	const u32 addr_and_length = (1 << 31) | offset;
+
+	frame->hdr.rx_flags = cpu_to_le32(0);
+	iowrite32(addr_and_length, fifo->reg);
+}
+
+static void ccat_eth_tx_fifo_dma_add_free(struct ccat_eth_fifo *const fifo)
+{
+	/* mark frame as ready to use for tx */
+	fifo->dma.next->hdr.tx_flags = cpu_to_le32(CCAT_FRAME_SENT);
+}
+
+static void fifo_dma_copy_to_linear_skb(struct ccat_eth_fifo *const fifo,
+					struct sk_buff *skb, const size_t len)
+{
+	skb_copy_to_linear_data(skb, fifo->dma.next->data, len);
+}
+
+static void fifo_dma_queue_skb(struct ccat_eth_fifo *const fifo,
+			       struct sk_buff *skb)
+{
+	struct ccat_dma_frame *frame = fifo->dma.next;
+	u32 addr_and_length;
+
+	frame->hdr.tx_flags = cpu_to_le32(0);
+	frame->hdr.length = cpu_to_le16(skb->len);
+
+	memcpy(frame->data, skb->data, skb->len);
+
+	/* Queue frame into CCAT TX-FIFO, CCAT ignores the first 8 bytes of the tx descriptor */
+	addr_and_length = offsetof(struct ccat_dma_frame_hdr, length);
+	addr_and_length += ((void *)frame - fifo->dma.start);
+	addr_and_length +=
+	    ((skb->len + sizeof(struct ccat_dma_frame_hdr)) / 8) << 24;
+	iowrite32(addr_and_length, fifo->reg);
+}
+
 static void ccat_eth_priv_free_dma(struct ccat_eth_priv *priv)
 {
 	/* reset hw fifo's */
@@ -176,20 +497,81 @@ static void ccat_eth_priv_free_dma(struc
  */
 static int ccat_eth_priv_init_dma(struct ccat_eth_priv *priv)
 {
-	if (ccat_eth_dma_fifo_init
-	    (&priv->rx_fifo, priv->reg.rx_fifo, ccat_eth_rx_fifo_add,
-	     priv->info.rx_dma_chan, priv)) {
-		pr_warn("init Rx DMA fifo failed.\n");
-		return -1;
+	struct ccat_function *const func = priv->func;
+	struct pci_dev *pdev = func->ccat->pdev;
+	int status = 0;
+	priv->rx_ready = fifo_dma_rx_ready;
+	priv->tx_ready = fifo_dma_tx_ready;
+	priv->free = ccat_eth_priv_free_dma;
+
+	status =
+	    ccat_dma_init(&priv->rx_fifo.dma, func->info.rx_dma_chan,
+			  func->ccat->bar_2, &pdev->dev);
+	if (status) {
+		pr_info("init RX DMA memory failed.\n");
+		return status;
+	}
+
+	status =
+	    ccat_dma_init(&priv->tx_fifo.dma, func->info.tx_dma_chan,
+			  func->ccat->bar_2, &pdev->dev);
+	if (status) {
+		pr_info("init TX DMA memory failed.\n");
+		ccat_dma_free(&priv->rx_fifo.dma);
+		return status;
 	}
 
-	if (ccat_eth_dma_fifo_init
-	    (&priv->tx_fifo, priv->reg.tx_fifo, ccat_eth_tx_fifo_add_free,
-	     priv->info.tx_dma_chan, priv)) {
-		pr_warn("init Tx DMA fifo failed.\n");
-		ccat_dma_free(&priv->rx_fifo.dma);
-		return -1;
-	}
+	priv->rx_fifo.add = ccat_eth_rx_fifo_dma_add;
+	priv->rx_fifo.copy_to_skb = fifo_dma_copy_to_linear_skb;
+	priv->rx_fifo.queue_skb = NULL;
+	priv->rx_fifo.end =
+	    ((struct ccat_eth_frame *)priv->rx_fifo.dma.start) + FIFO_LENGTH -
+	    1;
+	priv->rx_fifo.reg = priv->reg.rx_fifo;
+	ccat_eth_fifo_reset(&priv->rx_fifo);
+
+	priv->tx_fifo.add = ccat_eth_tx_fifo_dma_add_free;
+	priv->tx_fifo.copy_to_skb = NULL;
+	priv->tx_fifo.queue_skb = fifo_dma_queue_skb;
+	priv->tx_fifo.end =
+	    ((struct ccat_eth_frame *)priv->tx_fifo.dma.start) + FIFO_LENGTH -
+	    1;
+	priv->tx_fifo.reg = priv->reg.tx_fifo;
+	ccat_eth_fifo_reset(&priv->tx_fifo);
+
+	/* disable MAC filter */
+	iowrite8(0, priv->reg.mii + 0x8 + 6);
+	wmb();
+	return 0;
+}
+
+static int ccat_eth_priv_init_eim(struct ccat_eth_priv *priv)
+{
+	priv->rx_ready = fifo_eim_rx_ready;
+	priv->tx_ready = fifo_eim_tx_ready;
+	priv->free = ccat_eth_priv_free_eim;
+
+	priv->rx_fifo.eim.start = priv->reg.rx_mem;
+	priv->rx_fifo.eim.size = priv->func->info.rx_size;
+
+	priv->rx_fifo.add = fifo_eim_rx_add;
+	priv->rx_fifo.copy_to_skb = fifo_eim_copy_to_linear_skb;
+	priv->rx_fifo.queue_skb = NULL;
+	priv->rx_fifo.end = priv->rx_fifo.dma.start;
+	priv->rx_fifo.reg = NULL;
+	ccat_eth_fifo_reset(&priv->rx_fifo);
+
+	priv->tx_fifo.eim.start = priv->reg.tx_mem;
+	priv->tx_fifo.eim.size = priv->func->info.tx_size;
+
+	priv->tx_fifo.add = fifo_eim_tx_add;
+	priv->tx_fifo.copy_to_skb = NULL;
+	priv->tx_fifo.queue_skb = fifo_eim_queue_skb;
+	priv->tx_fifo.end =
+	    priv->tx_fifo.dma.start + priv->tx_fifo.dma.size -
+	    sizeof(struct ccat_eth_frame);
+	priv->tx_fifo.reg = priv->reg.tx_fifo;
+	ccat_eth_fifo_reset(&priv->tx_fifo);
 
 	/* disable MAC filter */
 	iowrite8(0, priv->reg.mii + 0x8 + 6);
@@ -198,31 +580,44 @@ static int ccat_eth_priv_init_dma(struct
 }
 
 /**
- * Initializes the CCat... members of the ccat_eth_priv structure.
- * Call this function only if info and ioaddr are already initialized!
+ * Initializes a struct ccat_eth_register with data from a corresponding
+ * CCAT function.
  */
-static void ccat_eth_priv_init_mappings(struct ccat_eth_priv *priv)
+static void ccat_eth_priv_init_reg(struct ccat_eth_register *const reg,
+				   const struct ccat_function *const func)
 {
 	struct ccat_mac_infoblock offsets;
-	void __iomem *const func_base =
-	    priv->ccatdev->bar[0].ioaddr + priv->info.addr;
+	void __iomem *const func_base = func->ccat->bar_0 + func->info.addr;
+
+	/* struct ccat_eth_fifo contains a union of ccat_dma, ccat_eim and ccat_mem
+	 * the members next, start and size have to overlay the exact same memory,
+	 * to support 'polymorphic' usage of them */
+	BUILD_BUG_ON(offsetof(struct ccat_dma, next) !=
+		     offsetof(struct ccat_mem, next));
+	BUILD_BUG_ON(offsetof(struct ccat_dma, start) !=
+		     offsetof(struct ccat_mem, start));
+	BUILD_BUG_ON(offsetof(struct ccat_dma, next) !=
+		     offsetof(struct ccat_eim, next));
+	BUILD_BUG_ON(offsetof(struct ccat_dma, start) !=
+		     offsetof(struct ccat_eim, start));
+	BUILD_BUG_ON(offsetof(struct ccat_dma, size) !=
+		     offsetof(struct ccat_eim, size));
 
 	memcpy_fromio(&offsets, func_base, sizeof(offsets));
-	priv->reg.mii = func_base + offsets.mii;
-	priv->reg.tx_fifo = func_base + offsets.tx_fifo;
-	priv->reg.rx_fifo = func_base + offsets.tx_fifo + 0x10;
-	priv->reg.mac = func_base + offsets.mac;
-	priv->reg.rx_mem = func_base + offsets.rx_mem;
-	priv->reg.tx_mem = func_base + offsets.tx_mem;
-	priv->reg.misc = func_base + offsets.misc;
+	reg->mii = func_base + offsets.mii;
+	reg->tx_fifo = func_base + offsets.tx_fifo;
+	reg->rx_fifo = func_base + offsets.tx_fifo + 0x10;
+	reg->mac = func_base + offsets.mac;
+	reg->rx_mem = func_base + offsets.rx_mem;
+	reg->tx_mem = func_base + offsets.tx_mem;
+	reg->misc = func_base + offsets.misc;
 }
 
 static netdev_tx_t ccat_eth_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
 	struct ccat_eth_priv *const priv = netdev_priv(dev);
-	struct ccat_eth_dma_fifo *const fifo = &priv->tx_fifo;
-	u32 addr_and_length;
+	struct ccat_eth_fifo *const fifo = &priv->tx_fifo;
 
 	if (skb_is_nonlinear(skb)) {
 		pr_warn("Non linear skb not supported -> drop frame.\n");
@@ -231,30 +626,22 @@ static netdev_tx_t ccat_eth_start_xmit(s
 		return NETDEV_TX_OK;
 	}
 
-	if (skb->len > sizeof(fifo->next->data)) {
+	if (skb->len > MAX_PAYLOAD_SIZE) {
 		pr_warn("skb.len %llu exceeds dma buffer %llu -> drop frame.\n",
-			(u64) skb->len, (u64) sizeof(fifo->next->data));
+			(u64) skb->len, (u64) MAX_PAYLOAD_SIZE);
 		atomic64_inc(&priv->tx_dropped);
 		priv->kfree_skb_any(skb);
 		return NETDEV_TX_OK;
 	}
 
-	if (!ccat_eth_frame_sent(fifo->next)) {
+	if (!priv->tx_ready(priv)) {
 		netdev_err(dev, "BUG! Tx Ring full when queue awake!\n");
 		priv->stop_queue(priv->netdev);
 		return NETDEV_TX_BUSY;
 	}
 
 	/* prepare frame in DMA memory */
-	fifo->next->tx_flags = cpu_to_le32(0);
-	fifo->next->length = cpu_to_le16(skb->len);
-	memcpy(fifo->next->data, skb->data, skb->len);
-
-	/* Queue frame into CCAT TX-FIFO, CCAT ignores the first 8 bytes of the tx descriptor */
-	addr_and_length = offsetof(struct ccat_eth_frame, length);
-	addr_and_length += ((void *)fifo->next - fifo->dma.virt);
-	addr_and_length += ((skb->len + CCAT_ETH_FRAME_HEAD_LEN) / 8) << 24;
-	iowrite32(addr_and_length, priv->reg.tx_fifo);
+	fifo->queue_skb(fifo, skb);
 
 	/* update stats */
 	atomic64_add(skb->len, &priv->tx_bytes);
@@ -263,7 +650,8 @@ static netdev_tx_t ccat_eth_start_xmit(s
 
 	ccat_eth_fifo_inc(fifo);
 	/* stop queue if tx ring is full */
-	if (!ccat_eth_frame_sent(fifo->next)) {
+
+	if (!priv->tx_ready(priv)) {
 		priv->stop_queue(priv->netdev);
 	}
 	return NETDEV_TX_OK;
@@ -286,11 +674,10 @@ static void ccat_eth_xmit_raw(struct net
 	ccat_eth_start_xmit(skb, dev);
 }
 
-static void ccat_eth_receive(struct net_device *const dev,
-			     const void *const data, const size_t len)
+static void ccat_eth_receive(struct ccat_eth_priv *const priv, const size_t len)
 {
 	struct sk_buff *const skb = dev_alloc_skb(len + NET_IP_ALIGN);
-	struct ccat_eth_priv *const priv = netdev_priv(dev);
+	struct net_device *const dev = priv->netdev;
 
 	if (!skb) {
 		pr_info("%s() out of memory :-(\n", __FUNCTION__);
@@ -299,7 +686,7 @@ static void ccat_eth_receive(struct net_
 	}
 	skb->dev = dev;
 	skb_reserve(skb, NET_IP_ALIGN);
-	skb_copy_to_linear_data(skb, data, len);
+	priv->rx_fifo.copy_to_skb(&priv->rx_fifo, skb, len);
 	skb_put(skb, len);
 	skb->protocol = eth_type_trans(skb, dev);
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
@@ -325,8 +712,8 @@ static void ccat_eth_link_up(struct net_
 	   speed == SPEED_100 ? 100 : 10,
 	   cmd.duplex == DUPLEX_FULL ? "Full" : "Half"); */
 
-	ccat_eth_dma_fifo_reset(&priv->rx_fifo);
-	ccat_eth_dma_fifo_reset(&priv->tx_fifo);
+	ccat_eth_fifo_reset(&priv->rx_fifo);
+	ccat_eth_fifo_reset(&priv->tx_fifo);
 
 	/* TODO reset CCAT MAC register */
 
@@ -366,19 +753,15 @@ static void poll_link(struct ccat_eth_pr
  */
 static void poll_rx(struct ccat_eth_priv *const priv)
 {
-	static const size_t overhead = CCAT_ETH_FRAME_HEAD_LEN - 4;
-	struct ccat_eth_dma_fifo *const fifo = &priv->rx_fifo;
+	struct ccat_eth_fifo *const fifo = &priv->rx_fifo;
+	size_t rx_per_poll = FIFO_LENGTH / 2;
+	size_t len = priv->rx_ready(fifo);
 
-	/* TODO omit possible deadlock in situations with heavy traffic */
-	while (ccat_eth_frame_received(fifo->next)) {
-		const size_t len = le16_to_cpu(fifo->next->length) - overhead;
-		if (priv->ecdev) {
-			ecdev_receive(priv->ecdev, fifo->next->data, len);
-		} else {
-			ccat_eth_receive(priv->netdev, fifo->next->data, len);
-		}
-		ccat_eth_rx_fifo_add(fifo, fifo->next);
+	while (len && --rx_per_poll) {
+		priv->receive(priv, len);
+		fifo->add(fifo);
 		ccat_eth_fifo_inc(fifo);
+		len = priv->rx_ready(fifo);
 	}
 }
 
@@ -393,7 +776,7 @@ static void ec_poll_rx(struct net_device
  */
 static void poll_tx(struct ccat_eth_priv *const priv)
 {
-	if (ccat_eth_frame_sent(priv->tx_fifo.next)) {
+	if (priv->tx_ready(priv)) {
 		netif_wake_queue(priv->netdev);
 	}
 }
@@ -408,7 +791,7 @@ static enum hrtimer_restart poll_timer_c
 	    container_of(timer, struct ccat_eth_priv, poll_timer);
 
 	poll_link(priv);
-	if(!priv->ecdev) {
+	if (!priv->ecdev) {
 		poll_rx(priv);
 		poll_tx(priv);
 	}
@@ -480,50 +863,60 @@ static const struct net_device_ops ccat_
 	.ndo_stop = ccat_eth_stop,
 };
 
-struct ccat_eth_priv *ccat_eth_init(const struct ccat_device *const ccatdev,
-				    const void __iomem * const addr)
+static struct ccat_eth_priv *ccat_eth_alloc_netdev(struct ccat_function *func)
 {
-	struct ccat_eth_priv *priv;
+	struct ccat_eth_priv *priv = NULL;
 	struct net_device *const netdev = alloc_etherdev(sizeof(*priv));
 
-	priv = netdev_priv(netdev);
-	priv->netdev = netdev;
-	priv->ccatdev = ccatdev;
+	if (netdev) {
+		priv = netdev_priv(netdev);
+		memset(priv, 0, sizeof(*priv));
+		priv->netdev = netdev;
+		priv->func = func;
+		ccat_eth_priv_init_reg(&priv->reg, func);
+	}
+	return priv;
+}
 
-	/* ccat register mappings */
-	memcpy_fromio(&priv->info, addr, sizeof(priv->info));
-	ccat_eth_priv_init_mappings(priv);
-
-	if (ccat_eth_priv_init_dma(priv)) {
-		pr_warn("%s(): DMA initialization failed.\n", __FUNCTION__);
-		free_netdev(netdev);
-		return NULL;
-	}
+static int ccat_eth_init_netdev(struct ccat_eth_priv *priv)
+{
+	int status;
 
 	/* init netdev with MAC and stack callbacks */
-	memcpy_fromio(netdev->dev_addr, priv->reg.mii + 8, netdev->addr_len);
-	netdev->netdev_ops = &ccat_eth_netdev_ops;
+	memcpy_fromio(priv->netdev->dev_addr, priv->reg.mii + 8,
+		      priv->netdev->addr_len);
+	priv->netdev->netdev_ops = &ccat_eth_netdev_ops;
 
 	/* use as EtherCAT device? */
-	priv->ecdev = ecdev_offer(netdev, ec_poll_rx, THIS_MODULE);
+	priv->carrier_off = ecdev_carrier_off;
+	priv->carrier_ok = ecdev_carrier_ok;
+	priv->carrier_on = ecdev_carrier_on;
+	priv->kfree_skb_any = ecdev_kfree_skb_any;
+
+	/* It would be more intuitive to check for:
+	 * if (priv->func->drv->type == CCATINFO_ETHERCAT_MASTER_DMA) {
+	 * unfortunately priv->func->drv is not initialized until probe() returns.
+	 * So we check if there is a rx dma fifo registered to determine dma/io mode */
+	if (priv->rx_fifo.reg) {
+		priv->receive = ecdev_receive_dma;
+	} else {
+		priv->receive = ecdev_receive_eim;
+	}
+	priv->start_queue = ecdev_nop;
+	priv->stop_queue = ecdev_nop;
+	priv->unregister = unregister_ecdev;
+	priv->ecdev = ecdev_offer(priv->netdev, ec_poll_rx, THIS_MODULE);
 	if (priv->ecdev) {
-		priv->carrier_off = ecdev_carrier_off;
-		priv->carrier_ok = ecdev_carrier_ok;
-		priv->carrier_on = ecdev_carrier_on;
-		priv->kfree_skb_any = ecdev_kfree_skb_any;
-		priv->start_queue = ecdev_nop;
-		priv->stop_queue = ecdev_nop;
-		priv->unregister = unregister_ecdev;
-
-		priv->carrier_off(netdev);
+		priv->carrier_off(priv->netdev);
 		if (ecdev_open(priv->ecdev)) {
 			pr_info("unable to register network device.\n");
 			ecdev_withdraw(priv->ecdev);
-			ccat_eth_priv_free_dma(priv);
-			free_netdev(netdev);
-			return NULL;
+			priv->free(priv);
+			free_netdev(priv->netdev);
+			return -1;	// TODO return better error code
 		}
-		return priv;
+		priv->func->private_data = priv;
+		return 0;
 	}
 
 	/* EtherCAT disabled -> prepare normal ethernet mode */
@@ -531,24 +924,82 @@ struct ccat_eth_priv *ccat_eth_init(cons
 	priv->carrier_ok = netif_carrier_ok;
 	priv->carrier_on = netif_carrier_on;
 	priv->kfree_skb_any = dev_kfree_skb_any;
+	priv->receive = ccat_eth_receive;
 	priv->start_queue = netif_start_queue;
 	priv->stop_queue = netif_stop_queue;
 	priv->unregister = unregister_netdev;
+	priv->carrier_off(priv->netdev);
 
-	priv->carrier_off(netdev);
-	if (register_netdev(netdev)) {
+	status = register_netdev(priv->netdev);
+	if (status) {
 		pr_info("unable to register network device.\n");
-		ccat_eth_priv_free_dma(priv);
-		free_netdev(netdev);
-		return NULL;
+		priv->free(priv);
+		free_netdev(priv->netdev);
+		return status;
 	}
-	pr_info("registered %s as network device.\n", netdev->name);
-	return priv;
+	pr_info("registered %s as network device.\n", priv->netdev->name);
+	priv->func->private_data = priv;
+	return 0;
+}
+
+static int ccat_eth_dma_probe(struct ccat_function *func)
+{
+	struct ccat_eth_priv *priv = ccat_eth_alloc_netdev(func);
+	int status;
+
+	if (!priv)
+		return -ENOMEM;
+
+	status = ccat_eth_priv_init_dma(priv);
+	if (status) {
+		pr_warn("%s(): DMA initialization failed.\n", __FUNCTION__);
+		free_netdev(priv->netdev);
+		return status;
+	}
+	return ccat_eth_init_netdev(priv);
 }
 
-void ccat_eth_remove(struct ccat_eth_priv *const priv)
+static void ccat_eth_dma_remove(struct ccat_function *func)
+{
+	struct ccat_eth_priv *const eth = func->private_data;
+	eth->unregister(eth->netdev);
+	eth->free(eth);
+	free_netdev(eth->netdev);
+}
+
+struct ccat_driver eth_dma_driver = {
+	.type = CCATINFO_ETHERCAT_MASTER_DMA,
+	.probe = ccat_eth_dma_probe,
+	.remove = ccat_eth_dma_remove,
+};
+
+static int ccat_eth_eim_probe(struct ccat_function *func)
 {
-	priv->unregister(priv->netdev);
-	ccat_eth_priv_free_dma(priv);
-	free_netdev(priv->netdev);
+	struct ccat_eth_priv *priv = ccat_eth_alloc_netdev(func);
+	int status;
+
+	if (!priv)
+		return -ENOMEM;
+
+	status = ccat_eth_priv_init_eim(priv);
+	if (status) {
+		pr_warn("%s(): memory initialization failed.\n", __FUNCTION__);
+		free_netdev(priv->netdev);
+		return status;
+	}
+	return ccat_eth_init_netdev(priv);
 }
+
+static void ccat_eth_eim_remove(struct ccat_function *func)
+{
+	struct ccat_eth_priv *const eth = func->private_data;
+	eth->unregister(eth->netdev);
+	eth->free(eth);
+	free_netdev(eth->netdev);
+}
+
+struct ccat_driver eth_eim_driver = {
+	.type = CCATINFO_ETHERCAT_NODMA,
+	.probe = ccat_eth_eim_probe,
+	.remove = ccat_eth_eim_remove,
+};
diff --git a/devices/ccat/sram.c b/devices/ccat/sram.c
new file mode 100644
--- /dev/null
+++ b/devices/ccat/sram.c
@@ -0,0 +1,108 @@
+/**
+    Network Driver for Beckhoff CCAT communication controller
+    Copyright (C) 2015  Beckhoff Automation GmbH & Co. KG
+    Author: Patrick Bruenn <p.bruenn@beckhoff.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "module.h"
+#include <asm/io.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+
+#define CCAT_SRAM_DEVICES_MAX 4
+
+static ssize_t __sram_read(struct cdev_buffer *buffer, char __user * buf,
+			   size_t len, loff_t * off)
+{
+	memcpy_fromio(buffer->data, buffer->ccdev->ioaddr + *off, len);
+	if (copy_to_user(buf, buffer->data, len))
+		return -EFAULT;
+
+	*off += len;
+	return len;
+}
+
+static ssize_t ccat_sram_read(struct file *const f, char __user * buf,
+			      size_t len, loff_t * off)
+{
+	struct cdev_buffer *buffer = f->private_data;
+	const size_t iosize = buffer->ccdev->iosize;
+
+	if (*off >= iosize) {
+		return 0;
+	}
+
+	len = min(len, (size_t) (iosize - *off));
+
+	return __sram_read(buffer, buf, len, off);
+}
+
+static ssize_t ccat_sram_write(struct file *const f, const char __user * buf,
+			       size_t len, loff_t * off)
+{
+	struct cdev_buffer *const buffer = f->private_data;
+
+	if (*off + len > buffer->ccdev->iosize) {
+		return 0;
+	}
+
+	if (copy_from_user(buffer->data, buf, len)) {
+		return -EFAULT;
+	}
+
+	memcpy_toio(buffer->ccdev->ioaddr + *off, buffer->data, len);
+
+	*off += len;
+	return len;
+}
+
+static struct ccat_cdev dev_table[CCAT_SRAM_DEVICES_MAX];
+static struct ccat_class cdev_class = {
+	.instances = {0},
+	.count = CCAT_SRAM_DEVICES_MAX,
+	.devices = dev_table,
+	.name = "ccat_sram",
+	.fops = {
+		 .owner = THIS_MODULE,
+		 .open = ccat_cdev_open,
+		 .release = ccat_cdev_release,
+		 .read = ccat_sram_read,
+		 .write = ccat_sram_write,
+		 },
+};
+
+static int ccat_sram_probe(struct ccat_function *func)
+{
+	static const u8 NO_SRAM_CONNECTED = 0;
+	const u8 type = func->info.sram_width & 0x3;
+	const size_t iosize = (1 << func->info.sram_size);
+
+	pr_info("%s: 0x%04x rev: 0x%04x\n", __FUNCTION__, func->info.type,
+		func->info.rev);
+	if (type == NO_SRAM_CONNECTED) {
+		return -ENODEV;
+	}
+	return ccat_cdev_probe(func, &cdev_class, iosize);
+}
+
+struct ccat_driver sram_driver = {
+	.type = CCATINFO_SRAM,
+	.probe = ccat_sram_probe,
+	.remove = ccat_cdev_remove,
+	.cdev_class = &cdev_class,
+};
diff --git a/devices/ccat/update.c b/devices/ccat/update.c
--- a/devices/ccat/update.c
+++ b/devices/ccat/update.c
@@ -18,14 +18,13 @@
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 
-#include <linux/fs.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/uaccess.h>
 #include "module.h"
-#include "update.h"
 
+#define CCAT_DEVICES_MAX 5
 #define CCAT_DATA_IN_4 0x038
 #define CCAT_DATA_IN_N 0x7F0
 #define CCAT_DATA_OUT_4 0x030
@@ -46,18 +45,6 @@
 	((((B) * 0x0802LU & 0x22110LU) | ((B) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16)
 
 /**
- * struct update_buffer - keep track of a CCAT FPGA update
- * @update: pointer to a valid ccat_update object
- * @data: buffer used for write operations
- * @size: number of bytes written to the data buffer, if 0 on ccat_update_release() no data will be written to FPGA
- */
-struct update_buffer {
-	struct ccat_update *update;
-	char data[CCAT_FLASH_SIZE];
-	size_t size;
-};
-
-/**
  * wait_until_busy_reset() - wait until the busy flag was reset
  * @ioaddr: address of the CCAT Update function in PCI config space
  */
@@ -243,78 +230,34 @@ static int ccat_write_flash_block(void _
  * ccat_write_flash() - Write a new CCAT configuration to FPGA's flash
  * @update: a CCAT Update buffer containing the new FPGA configuration
  */
-static void ccat_write_flash(const struct update_buffer *const update)
+static void ccat_write_flash(const struct cdev_buffer *const buffer)
 {
-	const char *buf = update->data;
+	const char *buf = buffer->data;
 	u32 off = 0;
-	size_t len = update->size;
+	size_t len = buffer->size;
 
 	while (len > CCAT_WRITE_BLOCK_SIZE) {
-		ccat_write_flash_block(update->update->ioaddr, off,
+		ccat_write_flash_block(buffer->ccdev->ioaddr, off,
 				       (u16) CCAT_WRITE_BLOCK_SIZE, buf);
 		off += CCAT_WRITE_BLOCK_SIZE;
 		buf += CCAT_WRITE_BLOCK_SIZE;
 		len -= CCAT_WRITE_BLOCK_SIZE;
 	}
-	ccat_write_flash_block(update->update->ioaddr, off, (u16) len, buf);
-}
-
-/**
- * ccat_update_destroy() - Cleanup the CCAT Update function
- * @ref: pointer to a struct kref embedded into a struct ccat_update, which we intend to destroy
- *
- * Retrieves the parent struct ccat_update and destroys it.
- */
-static void ccat_update_destroy(struct kref *ref)
-{
-	struct ccat_update *update =
-	    container_of(ref, struct ccat_update, refcount);
-
-	cdev_del(&update->cdev);
-	device_destroy(update->class, update->dev);
-	class_destroy(update->class);
-	unregister_chrdev_region(update->dev, 1);
-	kfree(update);
-	pr_debug("%s(): done\n", __FUNCTION__);
-}
-
-static int ccat_update_open(struct inode *const i, struct file *const f)
-{
-	struct ccat_update *update =
-	    container_of(i->i_cdev, struct ccat_update, cdev);
-	struct update_buffer *buf;
-
-	kref_get(&update->refcount);
-	if (atomic_read(&update->refcount.refcount) > 2) {
-		kref_put(&update->refcount, ccat_update_destroy);
-		return -EBUSY;
-	}
-
-	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
-	if (!buf) {
-		kref_put(&update->refcount, ccat_update_destroy);
-		return -ENOMEM;
-	}
-
-	buf->update = update;
-	f->private_data = buf;
-	return 0;
+	ccat_write_flash_block(buffer->ccdev->ioaddr, off, (u16) len, buf);
 }
 
 static int ccat_update_release(struct inode *const i, struct file *const f)
 {
-	const struct update_buffer *const buf = f->private_data;
-	struct ccat_update *const update = buf->update;
+	const struct cdev_buffer *const buf = f->private_data;
+	void __iomem *ioaddr = buf->ccdev->ioaddr;
 
 	if (buf->size > 0) {
-		ccat_update_cmd(update->ioaddr, CCAT_WRITE_ENABLE);
-		ccat_update_cmd(update->ioaddr, CCAT_BULK_ERASE);
-		ccat_wait_status_cleared(update->ioaddr);
+		ccat_update_cmd(ioaddr, CCAT_WRITE_ENABLE);
+		ccat_update_cmd(ioaddr, CCAT_BULK_ERASE);
+		ccat_wait_status_cleared(ioaddr);
 		ccat_write_flash(buf);
 	}
-	kfree(f->private_data);
-	kref_put(&update->refcount, ccat_update_destroy);
-	return 0;
+	return ccat_cdev_release(i, f);
 }
 
 /**
@@ -333,18 +276,16 @@ static int ccat_update_release(struct in
 static ssize_t ccat_update_read(struct file *const f, char __user * buf,
 				size_t len, loff_t * off)
 {
-	struct update_buffer *update = f->private_data;
+	struct cdev_buffer *buffer = f->private_data;
+	const size_t iosize = buffer->ccdev->iosize;
 
-	if (!buf || !off) {
-		return -EINVAL;
-	}
-	if (*off >= CCAT_FLASH_SIZE) {
+	if (*off >= iosize) {
 		return 0;
 	}
-	if (*off + len >= CCAT_FLASH_SIZE) {
-		len = CCAT_FLASH_SIZE - *off;
-	}
-	return ccat_read_flash(update->update->ioaddr, buf, len, off);
+
+	len = min(len, (size_t) (iosize - *off));
+
+	return ccat_read_flash(buffer->ccdev->ioaddr, buf, len, off);
 }
 
 /**
@@ -355,105 +296,56 @@ static ssize_t ccat_update_read(struct f
  * @off: current offset in the configuration data
  *
  * Copies data from user space (possibly a *.rbf) to the CCAT FPGA's
- * configuration flash to user space.
+ * configuration flash.
  *
  * Return: the number of bytes written, or 0 if flash end is reached
  */
-
 static ssize_t ccat_update_write(struct file *const f, const char __user * buf,
 				 size_t len, loff_t * off)
 {
-	struct update_buffer *const update = f->private_data;
+	struct cdev_buffer *const buffer = f->private_data;
 
-	if (*off + len > sizeof(update->data))
+	if (*off + len > buffer->ccdev->iosize) {
 		return 0;
+	}
 
-	if (copy_from_user(update->data + *off, buf, len)) {
+	if (copy_from_user(buffer->data + *off, buf, len)) {
 		return -EFAULT;
 	}
 
 	*off += len;
-	update->size = *off;
+	buffer->size = *off;
 	return len;
 }
 
-static struct file_operations update_ops = {
-	.owner = THIS_MODULE,
-	.open = ccat_update_open,
-	.release = ccat_update_release,
-	.read = ccat_update_read,
-	.write = ccat_update_write,
+static struct ccat_cdev dev_table[CCAT_DEVICES_MAX];
+static struct ccat_class cdev_class = {
+	.count = CCAT_DEVICES_MAX,
+	.devices = dev_table,
+	.name = "ccat_update",
+	.fops = {
+		 .owner = THIS_MODULE,
+		 .open = ccat_cdev_open,
+		 .release = ccat_update_release,
+		 .read = ccat_update_read,
+		 .write = ccat_update_write,
+		 },
 };
 
-/**
- * ccat_get_prom_id() - Read CCAT PROM ID
- * @ioaddr: address of the CCAT Update function in PCI config space
- *
- * Return: the CCAT FPGA's PROM identifier
- */
-u8 ccat_get_prom_id(void __iomem * const ioaddr)
+static int ccat_update_probe(struct ccat_function *func)
 {
-	ccat_update_cmd(ioaddr, CCAT_GET_PROM_ID);
-	return ioread8(ioaddr + 0x38);
+	static const u16 SUPPORTED_REVISION = 0x00;
+
+	if (SUPPORTED_REVISION != func->info.rev) {
+		pr_warn("CCAT Update rev. %d not supported\n", func->info.rev);
+		return -ENODEV;
+	}
+	return ccat_cdev_probe(func, &cdev_class, CCAT_FLASH_SIZE);
 }
 
-/**
- * ccat_update_init() - Initialize the CCAT Update function
- */
-struct ccat_update *ccat_update_init(const struct ccat_device *const ccatdev,
-				     void __iomem * const addr)
-{
-	struct ccat_update *const update = kzalloc(sizeof(*update), GFP_KERNEL);
-
-	if (!update) {
-		return NULL;
-	}
-	kref_init(&update->refcount);
-	update->ioaddr = ccatdev->bar[0].ioaddr + ioread32(addr + 0x8);
-	memcpy_fromio(&update->info, addr, sizeof(update->info));
-
-	if (0x00 != update->info.rev) {
-		pr_warn("CCAT Update rev. %d not supported\n",
-			update->info.rev);
-		goto cleanup;
-	}
-
-	if (alloc_chrdev_region(&update->dev, 0, 1, KBUILD_MODNAME)) {
-		pr_warn("alloc_chrdev_region() failed\n");
-		goto cleanup;
-	}
-
-	update->class = class_create(THIS_MODULE, "ccat_update");
-	if (NULL == update->class) {
-		pr_warn("Create device class failed\n");
-		goto cleanup;
-	}
-
-	if (NULL ==
-	    device_create(update->class, NULL, update->dev, NULL,
-			  "ccat_update")) {
-		pr_warn("device_create() failed\n");
-		goto cleanup;
-	}
-
-	cdev_init(&update->cdev, &update_ops);
-	update->cdev.owner = THIS_MODULE;
-	update->cdev.ops = &update_ops;
-	if (cdev_add(&update->cdev, update->dev, 1)) {
-		pr_warn("add update device failed\n");
-		goto cleanup;
-	}
-	return update;
-cleanup:
-	kref_put(&update->refcount, ccat_update_destroy);
-	return NULL;
-}
-
-/**
- * ccat_update_remove() - Prepare the CCAT Update function for removal
- */
-void ccat_update_remove(struct ccat_update *update)
-{
-	kref_put(&update->refcount, ccat_update_destroy);
-	pr_debug("%s(): done\n", __FUNCTION__);
-}
+struct ccat_driver update_driver = {
+	.type = CCATINFO_EPCS_PROM,
+	.probe = ccat_update_probe,
+	.remove = ccat_cdev_remove,
+	.cdev_class = &cdev_class,
+};
